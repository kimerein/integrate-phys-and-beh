function commonReference_usingDistractor(beh1_tbt,beh2_tbt,fieldtoalign,referencefield)

% Note that I selected a subset of trials for each of beh1_tbt and
% beh2_tbt, depending on which trials were present in physiology and
% photometry
% Also, further alignment of distractors has subtly shifted
% times_wrt_trial_start
% And these times_wrt_trial_start match the times in physiology or
% photometry structures
% HOWEVER, movie_distractor should be the same in both behavior_tbt's
% Thus, need to align trial indices, then save referents for how
% times_wrt_trial_start lines up in two beh_tbt's

maxTrialsLag=20; % should not be more than this many trials missing in the middle
R_thresh=0.95; % threshold for correlation coefficient, if this is the right trial alignment
% note that beh1_tbt and beh2_tbt were originally derived from the same
% array, thus should be exactly matching when correctly aligned

data1=beh1_tbt.(fieldtoalign);
data2=beh2_tbt.(fieldtoalign);
backup_data1=data1;
backup_data2=data2;
data1_trialinds=repmat([1:size(data1,1)]',1,size(data1,2)).*ones(size(data1));
data2_trialinds=repmat([1:size(data2,1)]',1,size(data2,2)).*ones(size(data2));
backup_data1_trialinds=data1_trialinds;
backup_data2_trialinds=data2_trialinds;
data1=data1';
data2=data2';
data1_trialinds=data1_trialinds';
data2_trialinds=data2_trialinds';
data1=data1(1:end);
data2=data2(1:end);
data1_trialinds=data1_trialinds(1:end);
data2_trialinds=data2_trialinds(1:end);
data1(isnan(data1))=0;
data2(isnan(data2))=0;

% Start with a global alignment
% Pad according to global alignment, then refine
[Xa,Ya,D]=alignsignals(data1,data2);
if D>0
    linedUp_trialinds_Ya=data2_trialinds; linedUp_trialinds_Xa=[zeros(1,abs(D)) data1_trialinds];
    D_trials=linedUp_trialinds_Ya(find(linedUp_trialinds_Xa>0,1,'first'))-1;
    [backup_data1_trialinds,backup_data2_trialinds]=prepend_to_data1(backup_data1_trialinds,backup_data2_trialinds,D_trials);
    [backup_data1,backup_data2]=prepend_to_data1(backup_data1,backup_data2,D_trials);
elseif D<0
    linedUp_trialinds_Xa=data1_trialinds; linedUp_trialinds_Ya=[zeros(1,abs(D)) data2_trialinds];
    D_trials=linedUp_trialinds_Xa(find(linedUp_trialinds_Ya>0,1,'first'))-1;
    [backup_data2_trialinds,backup_data1_trialinds]=prepend_to_data1(backup_data2_trialinds,backup_data1_trialinds,D_trials);
    [backup_data2,backup_data1]=prepend_to_data1(backup_data2,backup_data1,D_trials);
else
    linedUp_trialinds_Xa=data1_trialinds; linedUp_trialinds_Ya=data2_trialinds;
end
figure(); plot(Xa,'Color','k'); hold on; plot(Ya,'Color','r'); title('Initial global alignment'); ylabel('Trial indices');
checkAlignment(backup_data1*1.5,backup_data2); title('After global alignment');

% But trials may have been dropped in the middle of session
% So then proceed to check for best aligned trial for each trial
% individually
correct_backup_data2_trialinds=backup_data2_trialinds;
for i=1:size(backup_data1,1)
    if i>size(backup_data1,1)
        break
    end
    if i>size(backup_data2,1)
        break
    end
    R=corrcoef(backup_data1(i,:),backup_data2(i,:));
    if isnan(R(1,2)) || R(1,2)<R_thresh
        % if R is nan or less than R_thresh, find correct trial
        test_R=nan(1,length(i-maxTrialsLag:i+maxTrialsLag));
        k=1;
        for j=i-maxTrialsLag:i+maxTrialsLag
            if j<1 || j>size(backup_data2,1)
                continue
            end
            temp=corrcoef(backup_data1(i,:),backup_data2(j,:));
            test_R(k)=temp(1,2);
            k=k+1;
        end
        % find best alignment
        [~,bestalign]=nanmax(test_R);
        correct_backup_data2_trialinds(i,:)=ones(size(correct_backup_data2_trialinds(i,:))).*mode(backup_data2_trialinds(i-maxTrialsLag+(bestalign-1),:));
    end
end
% Adjust backup_data1 and backup_data2 according to correct trial-by-trial
% alignment
for i=1:size(backup_data1,1)
    
end

checkAlignment(backup_data1*1.5,backup_data2); title('After trial-by-trial alignment');

end

function [backup_data1_trialinds,backup_data2_trialinds]=prepend_to_data1(backup_data1_trialinds,backup_data2_trialinds,D)

% always prepends to first argument

backup_data1_trialinds=[nan(abs(D),size(backup_data1_trialinds,2)); backup_data1_trialinds];
backup_data2_trialinds=[backup_data2_trialinds; nan(size(backup_data1_trialinds,1)-size(backup_data2_trialinds,1),size(backup_data2_trialinds,2))];

end

function checkAlignment(dis1,dis2)

figure();
offset=0;
for i=1:size(dis1,1)
    if i>size(dis1,1)
        disp('skipping end of dis1');
        break
    end
    if i>size(dis2,1)
        disp('skipping end of dis2');
        break
    end
    plot(offset+dis1(i,:),'Color','k');
    hold on;
    plot(offset+dis2(i,:),'Color','r');
    offset=offset+nanmax([dis1(i,:) dis2(i,:)])+0.1;
end

end