function recodeMissVGrab

currentVid='Z:\MICROSCOPE\Kim\WHISPER recs\Oct_B\20210312\O2 output\2021-03-12 16-44-31-C_processed_data';
datestr='20210312';
mousename='Oct_B';

f_pr=regexp(currentVid,'_processed_data');
fslash=regexp(currentVid,'\');
aviName=currentVid(fslash(end)+1:f_pr-1);
placeForO2data=['Z:\MICROSCOPE\Kim\WHISPER recs\' mousename '\' datestr '\O2 output\' aviName];

load([currentVid '\tbt.mat'])
backuptbt=tbt;
load([currentVid '\final_aligned_data.mat'])
load([placeForO2data '_zoneVals.mat'])
load([placeForO2data '_eat.mat'])
load([placeForO2data '_savehandles.mat'])
load([placeForO2data '_paw.mat'])
newtbt=postAnalysis_checkForPelletDislodged(tbt,alignment,savehandles,zoneVals,eat);
newtbt=addReachBatchesToSingleTbt(newtbt,'cueZone_onVoff',0.25,0,[]);
tbt=newtbt;

save([currentVid '\backuptbt.mat'],'backuptbt');
save([currentVid '\tbt.mat'],'tbt');

% if have already fixed success v drop, recode all reaches using success v
% drop threshold


fid=fopen([currentVid '\fixed_miss_v_grab.txt'],'wt');
fclose(fid);

end

function out=getClassificationsAllTrials(tbt,successReachName,dropReachName,movieframesEarlyChews,t,frameTimes,eat,ninds_subsequent,x_thresh,y_thresh,delay,delayTime,overweightFP,eatZone,showROCthresh,isCurrReachStarts,isCurrPaw,mdl,didFlipMdlLabels)

temp=tbt.(successReachName);
temp=temp(1:end);
temp=temp';
fi=find(temp>0.5);
temp=tbt.movieframeinds(1:end);
linearmovieframes=temp';
temp=isCurrReachStarts(1:end);
lineariscurrreachstarts=temp';
temp=isCurrPaw(1:end);
lineariscurrpaw=temp';
subsequent_chewingPower=nan(1,length(fi));
subsequent_chewingDuration=nan(1,length(fi));
rawIntensity=nan(1,length(fi));
% chewFreqs=nan(1,length(fi));
% figure(); plot(t,eat.chewingpower); title('chewing power');
out.chewingPower=[];
out.chewingDuration=[];
out.movieFrameInds=[];
out.rawIntensity=[];
% out.chewFreqs=[];
out.isCurrReachStart=[];
out.isCurrReachPaw=[];
for i=1:length(fi)
    currmovieind=linearmovieframes(fi(i));
    useCurrReachBecauseReachStarts=lineariscurrreachstarts(fi(i));
    useCurrReachPaw=lineariscurrpaw(fi(i));
    [~,mi]=nanmin(abs(movieframesEarlyChews-currmovieind));
    [~,closest_t]=nanmin(abs(t-frameTimes(mi)));
    if ~isempty(delay)
        [~,closest_t]=nanmin(abs(t-(frameTimes(mi)+delayTime)));
        mi=mi+delay;
    end
    if mi>length(eatZone)
        continue
    end
    if closest_t+ninds_subsequent>length(eat.chewingpower)
        subsequent_chewingPower(i)=nanmean(eat.chewingpower(closest_t:end));
%         chewFreqs(i)=nanmean(chewingFreqs(closest_t:end));
    else
        subsequent_chewingPower(i)=nanmean(eat.chewingpower(closest_t:closest_t+ninds_subsequent));
%         chewFreqs(i)=nanmean(chewingFreqs(closest_t:closest_t+ninds_subsequent));
    end
    if mi+ninds_subsequent>length(eat.isChewing)
        subsequent_chewingDuration(i)=nansum(eat.isChewing(mi:end))*(ninds_subsequent/length(eat.isChewing(mi:end)));
        rawIntensity(i)=nanmax(eatZone(mi:end));
    else
        subsequent_chewingDuration(i)=nansum(eat.isChewing(mi:mi+ninds_subsequent));
        rawIntensity(i)=nanmax(eatZone(mi:mi+ninds_subsequent));
    end
    out.chewingPower(i)=subsequent_chewingPower(i);
    out.chewingDuration(i)=subsequent_chewingDuration(i);
    out.rawIntensity(i)=rawIntensity(i);
    %         out.chewFreqs(i)=chewFreqs(i);
    out.movieFrameInds(i)=currmovieind;
    out.isCurrReachStart(i)=useCurrReachBecauseReachStarts;
    out.isCurrReachPaw(i)=useCurrReachPaw;
end

temp=tbt.(dropReachName);
temp=temp(1:end);
temp=temp';
fi=find(temp>0.5);
subsequent_chewingPower=nan(1,length(fi));
subsequent_chewingDuration=nan(1,length(fi));
rawIntensity=nan(1,length(fi));
currmovieind=[];
useCurrReachBecauseReachStarts=[];
useCurrReachPaw=[];
% chewFreqs=nan(1,length(fi));
for i=1:length(fi)
    currmovieind=linearmovieframes(fi(i));
    useCurrReachBecauseReachStarts=lineariscurrreachstarts(fi(i));
    useCurrReachPaw=lineariscurrpaw(fi(i));
    [~,mi]=nanmin(abs(movieframesEarlyChews-currmovieind));
    [~,closest_t]=nanmin(abs(t-frameTimes(mi)));
    if ~isempty(delay)
        [~,closest_t]=nanmin(abs(t-(frameTimes(mi)+delayTime)));
        mi=mi+delay;
    end
    if mi>length(eatZone)
        continue
    end
    if closest_t+ninds_subsequent>length(eat.chewingpower)
        subsequent_chewingPower(i)=nanmean(eat.chewingpower(closest_t:end));
%         chewFreqs(i)=nanmean(chewingFreqs(closest_t:end));
    else
        subsequent_chewingPower(i)=nanmean(eat.chewingpower(closest_t:closest_t+ninds_subsequent));
%         chewFreqs(i)=nanmean(chewingFreqs(closest_t:closest_t+ninds_subsequent));
    end
    if mi+ninds_subsequent>length(eat.isChewing)
        subsequent_chewingDuration(i)=nansum(eat.isChewing(mi:end))*(ninds_subsequent/length(eat.isChewing(mi:end)));
        rawIntensity(i)=nanmax(eatZone(mi:end));
    else
        subsequent_chewingDuration(i)=nansum(eat.isChewing(mi:mi+ninds_subsequent));
        rawIntensity(i)=nanmax(eatZone(mi:mi+ninds_subsequent));
    end
    out.drop_chewingPower(i)=subsequent_chewingPower(i);
    out.drop_chewingDuration(i)=subsequent_chewingDuration(i);
    out.drop_rawIntensity(i)=rawIntensity(i);
    %         out.chewFreqs(i)=chewFreqs(i);
    out.drop_movieFrameInds(i)=currmovieind;
    out.drop_isCurrReachStart(i)=useCurrReachBecauseReachStarts;
    out.drop_isCurrReachPaw(i)=useCurrReachPaw;
end

out.chewingDuration=[out.chewingDuration subsequent_chewingDuration];
out.chewingPower=[out.chewingPower subsequent_chewingPower];
out.rawIntensity=[out.rawIntensity rawIntensity];
out.movieFrameInds=[out.movieFrameInds currmovieind];
out.isCurrReachStart=[out.isCurrReachStart useCurrReachBecauseReachStarts];
out.isCurrReachPaw=[out.isCurrReachPaw useCurrReachPaw];
if useSVM==true && ~isempty(out.chewingDuration) && ~isempty(mdl)
    X=[out.chewingDuration' out.chewingPower' out.rawIntensity'];
    out.predictions=predict(mdl,X);
    if didFlipMdlLabels==true
        out.predictions=~out.predictions;
    end
else
    out.predictions=[];
end

end

function [out1_alldata,out2_alldata]=studyGrabVMiss(tbt,savehandles,zoneVals,eat,successReachName,dropReachName,successClassifyName,dropClassifyName,overweightFP,isCurrReachStarts,isCurrPaw)

movieframesEarlyChews=savehandles.discardFirstNFrames+[1:length(eat.isChewing)];
settings=autoReachAnalysisSettings;
params.Fs=settings.movie_fps;
params.tapers=settings.chew.tapers;
params.fpass=settings.chew.fpass; % in Hz
tempie=zoneVals.eatZone;
eatzone=tempie(savehandles.discardFirstNFrames+1:end);
% params.tapers=[3 1];
[S,t,f]=mtspecgramc(eatzone(~isnan(eatzone)),[5 0.25],params);
% [~,ma]=nanmax(S(:,f>4.2 & f<8),[],2);
% chewingFreqs=f(ma);
frameTimes=0:(1/settings.movie_fps):(length(movieframesEarlyChews(~isnan(movieframesEarlyChews)))-1)*(1/settings.movie_fps);

% first study the currently classified drop versus success trials to get
% criteria for distinguishing
disp('analyzing time window 1');
ntimes_subsequent=1.667; % in sec
% ntimes_subsequent=1.25; % in sec
% ntimes_subsequent=2; % in sec
ninds_subsequent=floor(ntimes_subsequent/(1/params.Fs));
[out1,bestThresh,bestThreshIntens]=getPowerDurationInWindow(tbt,successClassifyName,dropClassifyName,movieframesEarlyChews,t,frameTimes,eat,ninds_subsequent,[],[],[],[],overweightFP,eatzone,true,isCurrReachStarts,isCurrPaw);
if isempty(bestThresh) && isempty(bestThreshIntens)
    out1.threshold=['chewingPower>' num2str(-100000) ' & rawIntensity>' num2str(-100000)];
elseif isempty(bestThresh) && ~isempty(bestThreshIntens)
    out1.threshold=['chewingPower>' num2str(-100000) ' & rawIntensity>' num2str(bestThreshIntens)];
elseif ~isempty(bestThresh) && isempty(bestThreshIntens)
    out1.threshold=['chewingPower>' num2str(bestThresh) ' & rawIntensity>' num2str(-100000)];
else
    out1.threshold=['chewingPower>' num2str(bestThresh) ' & rawIntensity>' num2str(bestThreshIntens)];
end
if ~isempty(out1.predictions)
    out1.threshold=['predictions==' num2str(out1.isSuccessVal)];
end
disp('analyzing time window 2');
ntimes_subsequent=3.75; % in sec
delaytime=2; % in sec
ninds_subsequent=floor(ntimes_subsequent/(1/params.Fs));
delay=floor(delaytime/(1/params.Fs));
[out2,~,~,bestThreshDur]=getPowerDurationInWindow(tbt,successClassifyName,dropClassifyName,movieframesEarlyChews,t,frameTimes,eat,ninds_subsequent,[],[],delay,delaytime,overweightFP,eatzone,true,isCurrReachStarts,isCurrPaw);
if ~isempty(bestThreshDur)
    out2.threshold=['chewingDuration>' num2str(bestThreshDur)];
else
    out2.threshold=['chewingDuration>' num2str(-100000)];
end
if ~isempty(out2.predictions)
    out2.threshold=['predictions==' num2str(out2.isSuccessVal)];
end

% then get information about all currently considered trials
disp('getting all trials data for time window 1');
ntimes_subsequent=1.667; % in sec
ninds_subsequent=floor(ntimes_subsequent/(1/params.Fs));
out1_alldata=getClassificationsAllTrials(tbt,successReachName,dropReachName,movieframesEarlyChews,t,frameTimes,eat,ninds_subsequent,[],[],[],[],overweightFP,eatzone,true,isCurrReachStarts,isCurrPaw,out1.mdl,out1.didFlipMdlLabels);
out1_alldata.threshold=out1.threshold;
disp('getting all trials data for time window 2');
ntimes_subsequent=3.75; % in sec
delaytime=2; % in sec
ninds_subsequent=floor(ntimes_subsequent/(1/params.Fs));
delay=floor(delaytime/(1/params.Fs));
out2_alldata=getClassificationsAllTrials(tbt,successReachName,dropReachName,movieframesEarlyChews,t,frameTimes,eat,ninds_subsequent,[],[],delay,delaytime,overweightFP,eatzone,true,isCurrReachStarts,isCurrPaw,out2.mdl,out2.didFlipMdlLabels);
out2_alldata.threshold=out2.threshold;

end

function [tbt,finaldata]=postAnalysis_checkForPelletDislodged(tbt,finaldata,savehandles,zoneVals,eat)

fps=settings.movie_fps;

% Fix any reach values below 1
tbt=setAllAbove0to1(tbt,'reach');

% Take backups
if ~isfield(finaldata,'success_reachStarts_backup')
    finaldata.success_reachStarts_backup=finaldata.success_reachStarts;
    finaldata.drop_reachStarts_backup=finaldata.drop_reachStarts;
    finaldata.miss_reachStarts_backup=finaldata.miss_reachStarts;
    finaldata.success_reachStarts_pawOnWheel_backup=finaldata.success_reachStarts_pawOnWheel;
    finaldata.drop_reachStarts_pawOnWheel_backup=finaldata.drop_reachStarts_pawOnWheel;
    finaldata.miss_reachStarts_pawOnWheel_backup=finaldata.miss_reachStarts_pawOnWheel;
end

% If pellet is dislodged within 10 indices of end of reach start, then
% consider this a grab rather than a miss





% If want to start by considering every potential reach a success, then
% will trim accordingly
finaldata.success_reachStarts=(finaldata.success_reachStarts_backup + finaldata.drop_reachStarts_backup) > 0.5;

% First for reaches where paw does not start on wheel
finaldata.success_reachStarts_backup=finaldata.success_reachStarts;
[finaldata.success_reachStarts,newDrops,tbt]=checkForSufficientChewing(finaldata.success_reachStarts,finaldata.isChewing,minIndToPelletChew,withinXInds,dropIfChewingBefore,priorXInds,minIndMoreStringent,finaldata,tbt,finaldata.flippedThese,false);
finaldata.drop_reachStarts_backup=finaldata.drop_reachStarts;
finaldata.drop_reachStarts(newDrops==1)=1;

% For reaches where paw does start on wheel
finaldata.success_reachStarts_pawOnWheel_backup=finaldata.success_reachStarts_pawOnWheel;
[finaldata.success_reachStarts_pawOnWheel,newDrops,tbt]=checkForSufficientChewing(finaldata.success_reachStarts_pawOnWheel,finaldata.isChewing,minIndToPelletChew,withinXInds,dropIfChewingBefore,priorXInds,minIndMoreStringent,finaldata,tbt,finaldata.flippedThese_pawOnWheel,true);
finaldata.drop_reachStarts_pawOnWheel_backup=finaldata.drop_reachStarts_pawOnWheel;
finaldata.drop_reachStarts_pawOnWheel(newDrops==1)=1;

% Chewing power and duration thresholds
disp('Plotting which duration and power thresholds distinguish drop vs success');
% tbt.currentclassifysuccess=(tbt.('success_reachStarts_backup') + tbt.('success_reachStarts_pawOnWheel_backup')) > 0.5;
% tbt.currentclassifydrop=(tbt.('drop_reachStarts_backup') + tbt.('drop_reachStarts_pawOnWheel_backup')) > 0.5;
tbt.currentclassifysuccess=(tbt.('success_reachStarts') + tbt.('success_reachStarts_pawOnWheel')) > 0.5;
tbt.currentclassifydrop=(tbt.('drop_reachStarts') + tbt.('drop_reachStarts_pawOnWheel')) > 0.5;
if isfield(tbt,'all_reachBatch')
    tbt.currentstudysuccess=(tbt.('success_reachStarts') + tbt.('reachBatch_success_reachStarts') + tbt.('success_reachStarts_pawOnWheel') + tbt.('reachBatch_success_reachStarts_pawOnWheel')) > 0.5;
    tbt.currentstudydrop=(tbt.('drop_reachStarts') + tbt.('reachBatch_drop_reachStarts') + tbt.('drop_reachStarts_pawOnWheel') + tbt.('reachBatch_drop_reachStarts_pawOnWheel')) > 0.5;
else
    tbt.currentstudysuccess=(tbt.('success_reachStarts') + tbt.('success_reachStarts_pawOnWheel')) > 0.5;
    tbt.currentstudydrop=(tbt.('drop_reachStarts') + tbt.('drop_reachStarts_pawOnWheel')) > 0.5;
end
whichIsReachStarts_noPawOnWheel=tbt.('success_reachStarts')>0.5;
whichIsReachStarts_PawOnWheel=tbt.('success_reachStarts_pawOnWheel')>0.5;
[out1,out2]=studyChewingPowerAfterSuccessVsDrop(tbt,savehandles,zoneVals,eat,'currentstudysuccess','currentstudydrop','currentclassifysuccess','currentclassifydrop',overweightFP,whichIsReachStarts_noPawOnWheel,whichIsReachStarts_PawOnWheel);
chewingPower=out1.chewingPower(out1.isCurrReachStart==1);
chewingDuration=out1.chewingDuration(out1.isCurrReachStart==1);
rawIntensity=out1.rawIntensity(out1.isCurrReachStart==1);
if isempty(out1.predictions)
    tbt=rmfield(tbt,'currentstudysuccess');
    tbt=rmfield(tbt,'currentstudydrop');
    tbt=rmfield(tbt,'currentclassifysuccess');
    tbt=rmfield(tbt,'currentclassifydrop');
    return
end
predictions=out1.predictions(out1.isCurrReachStart==1);
currmovieFrameInds=out1.movieFrameInds(out1.isCurrReachStart==1);
s1=eval(out1.threshold);
nopawonwheel_thresh1=out1.threshold;
chewingPower=out2.chewingPower(out2.isCurrReachStart==1);
chewingDuration=out2.chewingDuration(out2.isCurrReachStart==1);
predictions=out2.predictions(out2.isCurrReachStart==1);
s2=eval(out2.threshold);
nopawonwheel_thresh2=out2.threshold;
theseAreSuccess=s1 & s2;
maybeDropMaybeSuccess=s1~=s2;
% disp([out1.movieFrameInds(out1.isCurrReachStart==1)' out2.movieFrameInds(out2.isCurrReachStart==1)'])
tbt=adjustTbtUsingThresh(currmovieFrameInds,tbt,theseAreSuccess,false,finaldata,maybeDropMaybeSuccess);

chewingPower=out1.chewingPower(out1.isCurrReachPaw==1);
chewingDuration=out1.chewingDuration(out1.isCurrReachPaw==1);
rawIntensity=out1.rawIntensity(out1.isCurrReachPaw==1);
predictions=out1.predictions(out1.isCurrReachPaw==1);
currmovieFrameInds=out1.movieFrameInds(out1.isCurrReachPaw==1);
s1=eval(out1.threshold);
chewingPower=out2.chewingPower(out2.isCurrReachPaw==1);
chewingDuration=out2.chewingDuration(out2.isCurrReachPaw==1);
predictions=out2.predictions(out2.isCurrReachPaw==1);
s2=eval(out2.threshold);
theseAreSuccess=s1 & s2;
maybeDropMaybeSuccess=s1~=s2;
tbt=adjustTbtUsingThresh(currmovieFrameInds,tbt,theseAreSuccess,true,finaldata,maybeDropMaybeSuccess);

tbt=rmfield(tbt,'currentstudysuccess');
tbt=rmfield(tbt,'currentstudydrop');
tbt=rmfield(tbt,'currentclassifysuccess');
tbt=rmfield(tbt,'currentclassifydrop');

end

function dataByFrames=mapToFrames(data,times,frameTimes)

dataByFrames=nan(size(frameTimes));

for i=1:length(times)
    [~,mi]=min(abs(times(i)-frameTimes));
    dataByFrames(mi)=data(i);
end

dataByFrames=fillInNans(dataByFrames);

end

function data=fillInNans(data)

inds=find(~isnan(data));
for i=1:length(inds)
    currind=inds(i);
    if i==1
        % fill in before
        data(1:currind-1)=data(currind);
    elseif i==length(inds)
        halfLength=floor((currind-inds(i-1))/2);
        data(inds(i-1)+1:inds(i-1)+1+halfLength)=data(inds(i-1));
        data(inds(i-1)+2+halfLength:currind-1)=data(currind);
        % fill in after
        data(currind+1:end)=data(currind);
    else
        % fill in with recent
        halfLength=floor((currind-inds(i-1))/2);
        data(inds(i-1)+1:inds(i-1)+1+halfLength)=data(inds(i-1));
        data(inds(i-1)+2+halfLength:currind-1)=data(currind);
    end
end
if any(isnan(data))
    error('Failed to replace all nans');
end     

end

function finalData=mapUsingMovieFrames(movieFramesInFinalData,dataToMap,framesInOrigData)

finalData=nan(size(movieFramesInFinalData));
for i=1:length(movieFramesInFinalData)
    [~,mi]=nanmin(abs(framesInOrigData-movieFramesInFinalData(i)));
    finalData(i)=dataToMap(mi);    
end

end

function tbt=setAllAbove0to1(tbt,ifFieldContains)

f=fieldnames(tbt);
for i=1:length(f)
    currfield=f{i};
    if ~isempty(regexp(currfield,ifFieldContains,'once'))
        tempie=zeros(size(tbt.(currfield)));
        tempie(tbt.(currfield)>0)=1;
        tbt.(currfield)=tempie;
    end
end

end

function tbt=adjustTbtUsingThresh(movieframes,tbt,theseAreSuccess,isPawOnWheel,finaldata)

for i=1:length(movieframes)
    movieframe=movieframes(i);
    temp=tbt.movieframeinds;
    [allmi,ms]=findAllMovieInds(movieframe,temp);
    for j=1:size(allmi,1)
        a=allmi(j,1);
        b=allmi(j,2);
        if theseAreSuccess(i)==true % if mouse actually grabbed pellet
            % is grab
            % make sure that tbt says success
            [~,movind]=nanmin(abs(finaldata.movieframeinds-movieframe));
            if isPawOnWheel==true
                tbt.success_reachStarts_pawOnWheel(a,b)=1;
                tbt.miss_reachStarts_pawOnWheel(a,b)=0;
            else
                tbt.success_reachStarts(a,b)=1;
                tbt.miss_reachStarts(a,b)=0;
            end
        else
            % is actually a miss
        end
    end  
end

end

function [allmi,ms]=findAllMovieInds(movieframe,allmovieframes)

allmi=[];
ms=[];
for i=1:1000
    [m,mi]=min(abs(allmovieframes-movieframe),[],'all','omitnan','linear');
    [a,b]=ind2sub(size(allmovieframes),mi);
    allmi=[allmi; [a,b]];
    ms=[ms; m];
    allmovieframes(a,b)=movieframe+1000;
    if m>0.5 && ~isempty(allmi)
        break
    end
end
allmi=allmi(ms<1,:);
ms=ms(ms<1);

end

function [tbt,new_success]=adjustTbtAccordingly(currReachInd,finaldata,tbt,flipped,currFlip,isPawOnWheel)

movieframe=finaldata.movieframeinds(currReachInd);
temp=tbt.movieframeinds;
[allmi,ms]=findAllMovieInds(movieframe,temp); % in case there are multiple instances of this time point at end and beginning of neighboring trials in tbt
% [~,mi]=min(abs(temp-movieframe),[],'all','omitnan','linear');
% [a,b]=ind2sub(size(temp),mi);
% if isempty(a) || isempty(b)
%     error('Could not find matching movie frame in tbt IN postAnalysis_checkForChewedPellet.m');
% end

new_success=false;
for i=1:size(allmi,1)
    a=allmi(i,1);
    b=allmi(i,2);
    if currFlip==true && flipped(currReachInd)==true
        % should flip tbt from success to drop
        % but tbt should already be flipped
    elseif currFlip==true && flipped(currReachInd)==false
        % flip now although didn't flip before
        if isPawOnWheel==true
            tbt.drop_reachStarts_pawOnWheel(a,b)=1;
            tbt.success_reachStarts_pawOnWheel(a,b)=0;
        else
            tbt.drop_reachStarts(a,b)=1;
            tbt.success_reachStarts(a,b)=0;
        end
    elseif currFlip==false && flipped(currReachInd)==false
        % don't flip
        % check whether is drop in tbt and make success
        if isPawOnWheel==true
            if tbt.drop_reachStarts_pawOnWheel(a,b)==1
                tbt.drop_reachStarts_pawOnWheel(a,b)=0;
                tbt.success_reachStarts_pawOnWheel(a,b)=1;
                new_success=true;
            end
        else
            if tbt.drop_reachStarts(a,b)==1
                tbt.drop_reachStarts(a,b)=0;
                tbt.success_reachStarts(a,b)=1;
                new_success=true;
            end
        end
        
    elseif currFlip==false && flipped(currReachInd)==true
        % previously flipped success to drop, but now flip back
        if isPawOnWheel==true
            tbt.drop_reachStarts_pawOnWheel(a,b)=0;
            tbt.success_reachStarts_pawOnWheel(a,b)=1;
        else
            tbt.drop_reachStarts(a,b)=0;
            tbt.success_reachStarts(a,b)=1;
        end
    end
end

end

function [reaches,newDrops,tbt]=checkForSufficientChewing(reaches,chewing,minIndToPelletChew,withinXInds,dropIfChewingBefore,priorXInds,minIndMoreStringent,finaldata,tbt,flipped,isPawOnWheel)

fi=find(reaches==1);
newDrops=zeros(size(reaches));
flippedBack=0;
newFlips=0;
newSuccesses=0;
for i=1:length(fi)
    currFlip=false;
    currReachInd=fi(i);
    % is there enough chewing within X seconds of this reach
    if currReachInd+withinXInds>length(chewing)
        chewInds=sum(chewing(currReachInd:end)>0.5);
    else
        chewInds=sum(chewing(currReachInd:currReachInd+withinXInds)>0.5);
    end
    if chewInds<minIndToPelletChew % not enough chewing to be consistent with eating pellet
        reaches(currReachInd)=0; % not a successful reach
        newDrops(currReachInd)=1; % actually a drop
        currFlip=true;
    end
    if dropIfChewingBefore==1 && newDrops(currReachInd)==0
        % was mouse chewing BEFORE reach?
        if currReachInd-priorXInds<1
            chewInds_before=sum(chewing(1:currReachInd-1)>0.5);
        else
            chewInds_before=sum(chewing(currReachInd-priorXInds:currReachInd-1)>0.5);
        end
        if chewInds_before>floor((minIndToPelletChew/withinXInds)*priorXInds)
            % mouse was chewing before reach
            % did mouse chew long enough after reach, consistent with
            % consumption of full pellet?
            if chewInds<minIndMoreStringent % not enough chewing to be consistent with eating pellet
                reaches(currReachInd)=0; % not a successful reach
                newDrops(currReachInd)=1; % actually a drop
                currFlip=true;
            end
        end
    end
    [tbt,new_success]=adjustTbtAccordingly(currReachInd,finaldata,tbt,flipped,currFlip,isPawOnWheel);
    if new_success==true
        newSuccesses=newSuccesses+1;
    end
    if currFlip==false && flipped(currReachInd)==true
        flippedBack=flippedBack+1;
    elseif currFlip==true && flipped(currReachInd)==false
        newFlips=newFlips+1;
    end
end
disp(['flipped back ' num2str(flippedBack)]);
disp(['new flips ' num2str(newFlips)]);
disp(['new successes ' num2str(newSuccesses)]);

end
